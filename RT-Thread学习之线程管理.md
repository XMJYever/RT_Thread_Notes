### 线程简介
线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，其本质是将复杂的应用(一个进程)分解成多个小的、可调度的、序列化的程序单元，当合理的划分任务并正确执行时，能够让系统满足实时系统的性能及时间的要求。
如下图所示，嵌入式系统执行任务A，该任务是系统通过传感器采集数据，然后输出到显示屏显示出来，在多线程实时系统中，可以将任务A分解成两个子任务。
![](thread.png)
在RT-Thread中，与上述子任务的程序实体就是线程，它描述了一个任务执行的运行环境，也描述了这个任务所处的优先等级，重要的任务可设置相对较高的优先级，非重要的任务可以设置较低的优先级，不同的任务还可以设置相同的优先级，轮流运行。
**上下文**：当线程运行时，它会认为自己是以独占CPU的方式运行，线程执行时的运行环境即为上下文，包括所有的寄存器变量、堆栈、内存信息等。
### 功能特点
* **线程管理的功能**：对线程进行管理和调度；
* **分类**：系统线程和用户线程；
* **系统线程**：由RT-Thread内核创建的线程，包括**空闲线程**和**主线程**；
* **用户线程**：是由应用程序创建的线程；
* 两种线程都会从内核对象容器中分配线程对象，当线程被删除时，也会被从对象容器中删除，如下图所示，每个线程都有重要的属性，如线程控制块、线程栈、入口函数等。
![](contour.png)
* RT-Thread的线程调度器是抢占式的，主要的工作是从就绪线程列表中查找最高优先级线程，保证最高优先级的线程能够被运行，最高优先级的任务一旦就绪，就能得到CPU的使用权；
* 当调度器调度线程切换时，先将当前线程上下文保存起来，当再切回到这个线程时，线程调度器将该线程的上下文信息恢复。
### 线程重要属性
#### 线程控制块
在 RT-Thread 中，线程控制块由结构体 struct rt_thread 表示，线程控制块是操作系统用于管理线程的一个数据结构，它会存放线程的一些信息，例如优先级、线程名称、线程状态等，也包含线程与线程之间连接用的链表结构，线程等待事件集合等。详细定义可参考[RT-Thread-线程管理](https://www.rt-thread.org/document/site/programming-manual/thread/thread/)
#### 线程栈
* RT-Thread 线程具有独立的栈，当进行线程切换时，会将当前线程的上下文存在栈中，当线程要恢复运行时，再从栈中读取上下文信息，进行恢复。
* 用来存放函数中的局部变量：函数中的局部变量从线程栈空间中申请；函数中局部变量初始时从寄存器中分配(ARM架构)，当这个函数再调用另一个函数时，这些局部变量将放入栈中。
* 入口函数(PC寄存器)、入口参数(R0寄存器)、返回位置(LR寄存器)、当前机器运行状态(CPSR寄存器)。
* 对于ARM Cortex-M架构来说，线程栈可构造如下图所示：
![](04thread_stack.png)
#### 线程状态
* 初始状态：线程开始创建还未运行，宏定义为RT_THREAD_INIT；
* 就绪状态：线程按照优先级排队，等待被执行；宏定义为RT_THREAD_READY；
* 运行状态：线程当前正在运行；宏定义为RT_THREAD_RUNNING；
* 挂起状态：可能因为资源不可用而挂起等待，或线程主动延时一段时间而挂起，此时不参与调度；宏定义为RT_THREAD_SUSPEND；
* 关闭状态：线程结束；宏定义为RT_THREAD_CLOSE。
#### 线程优先级
RT-Thread 最大支持 256 个线程优先级 (0\~255)，数值越小的优先级越高，0 为最高优先级。
#### 时间片
* 每个线程都有时间片这个参数，但时间片仅对优先级相同的就绪态线程有效。
* 系统对优先级相同的就绪态线程采用时间片轮转的调度方式进行调度时，时间片起到约束线程单次运行时长的作用，单位是一个OS Tick，如下图所示。
![](04time_slience.png)
#### 线程的入口函数
线程控制块中的 entry 是线程的入口函数，它是线程实现预期功能的函数。线程的入口函数由用户设计实现，一般有以下两种代码形式：
* 无限循环模式

```
void thread_entry(void* paramenter)
{
    while (1)
    {
    /* 等待事件的发生 */

    /* 对事件进行服务、进行处理 */
    }
}
```
* 顺序执行或有限次循环模式

```
static void thread_entry(void* parameter)
{
    /* 处理事务 #1 */
    …
    /* 处理事务 #2 */
    …
    /* 处理事务 #3 */
}
```
#### 线程状态切换
RT-Thread提供一系列的操作系统调用接口，使得线程的状态在这五个状态之间来回切换。几种状态间的转换关系如下图所示：
![](04thread_sta.png)

### 线程的管理方式
下图所示描述了线程的相关操作，包含：创建/初始化线程、启动线程、删除/脱离线程。
![](04thread_ops.png)
#### 创建和初始化线程
可以使用 rt_thread_create() 创建一个动态线程，使用 rt_thread_init() 初始化一个静态线程，动态线程与静态线程的区别是：动态线程是系统自动从动态内存堆上分配栈空间与线程句柄（初始化 heap 之后才能使用 create 创建动态线程），静态线程是由用户分配栈空间与线程句柄。
创建线程(动态线程，在使能了RT_USING_HEAP才有效)：
```
rt_thread_t rt_thread_create(const char* name,
                            void (*entry)(void* parameter),
                            void* parameter,
                            rt_uint32_t stack_size,
                            rt_uint8_t priority,
                            rt_uint32_t tick);
```
初始化线程：
```
rt_err_t rt_thread_init(struct rt_thread* thread,
                        const char* name,
                        void (*entry)(void* parameter), void* parameter,
                        void* stack_start, rt_uint32_t stack_size,
                        rt_uint8_t priority, rt_uint32_t tick);
```
#### 删除和脱离线程
删除线程：
```
rt_err_t rt_thread_delete(rt_thread_t thread);
```
脱离线程：
```
rt_err_t rt_thread_detach (rt_thread_t thread);
```
#### 启动线程
将初始化/创建成功后的线程通过启动线程接口进入就绪态：
```
rt_err_t rt_thread_startup(rt_thread_t thread);
```
#### 获得当前线程
```
rt_thread_t rt_thread_self(void);
```
#### 使线程让出处理器资源
当前线程的时间片用完或者该线程主动要求让出处理器资源时，它将不再占有处理器，调度器会选择相同优先级的下一个线程执行。
```
rt_err_t rt_thread_yield(void);
```
#### 使线程睡眠
在实际应用中，我们有时需要让运行的当前线程延迟一段时间，在指定的时间到达后重新运行，这就叫做 “线程睡眠”。
```
rt_err_t rt_thread_sleep(rt_tick_t tick);
rt_err_t rt_thread_delay(rt_tick_t tick);
rt_err_t rt_thread_mdelay(rt_int32_t ms);
```
#### 挂起和恢复线程
挂起线程：
处于挂起状态的线程，如果其等待的资源超时（超过其设定的等待时间），那么该线程将不再等待这些资源，并返回到就绪状态；或者，当其他线程释放掉该线程所等待的资源时，该线程也会返回到就绪状态。
```
rt_err_t rt_thread_suspend (rt_thread_t thread);
```
恢复线程：
让挂起的线程重新进入就绪状态，并将线程放入系统的就绪队列中；如果被恢复线程在所有就绪态线程中，位于最高优先级链表的第一位，那么系统将进行线程上下文的切换。
```
rt_err_t rt_thread_resume (rt_thread_t thread);
```
#### 控制线程
```
rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void* arg);
```
#### 设置和删除空闲钩子(hook)
空闲钩子函数是空闲线程的钩子函数，如果设置了空闲钩子函数，就可以在系统执行空闲线程时，自动执行空闲钩子函数来做一些其他事情，比如系统指示灯。设置 / 删除空闲钩子的接口如下：
```
rt_err_t rt_thread_idle_sethook(void (*hook)(void));
rt_err_t rt_thread_idle_delhook(void (*hook)(void));
```
#### 设置调度器钩子
* 在整个系统的运行时，系统都处于线程运行、中断触发 - 响应中断、切换到其他线程，甚至是线程间的切换过程中，或者说系统的上下文切换是系统中最普遍的事件。
* 有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。在系统线程切换时，这个钩子函数将被调用：

```
void rt_scheduler_sethook(void (*hook)(struct rt_thread* from, struct rt_thread* to));

```
* from: 表示系统所要切换出的线程控制块指针
* to: 表示系统所要切换到的线程控制块指针